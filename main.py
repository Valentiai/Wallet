from dataclasses import dataclass #с помощью датаклассов создаю класс Note
from datetime import date #с помощью него оперирую датами
from random import randint #с помощью него генерирую ID записи
from pprint import pprint #с помощью него вывожу словарь, содержащий все записи
import re #с помощью него проверяю ряд вводных на соответствие требуемому шаблону

def create_dict():
    '''с помощью этой функции создаю словарь, содержащий все записи'''
    with open('Database.txt', 'r', encoding='utf-8') as db:
        notes = []
        lines = db.readlines()
        n_qty = int(lines[3].split()[2])
        lines = lines[6:]
        line = 0
        for _ in range(n_qty):
            note = {}
            a,b,c,d,e,f = lines[line:line+6]
            note['ID записи'] = int(a.split()[-1])
            b = b.split()[-1]
            year,month,day = b.split('-')
            note['Дата записи'] = date(int(year),int(month),int(day)).strftime('%Y-%m-%d')
            note['Наименование категории'] = c.split()[-1]
            note['Сумма'] = d.split()[-1]
            note['Описание'] = e.split()[-1]
            notes.append(note)
            line+=6
    return notes

def delete_note(line):
    '''с помощью этой функции удаляю имеющуюся запись по номеру строки, содержащему искомый ID.
    функция ничего не возвращает'''
    with open('Database.txt', 'r+', encoding='utf-8') as db:
        lines = db.readlines()
        a,b = lines[line+3].split(': ')
        lines = income_loss_edit(b[0], float(b[1:-1]))
        lines = lines[:line]+lines[line+6:]
        count = 1
        for i in range(len(lines)):
            if 'ID' in lines[i]:
                a,b = lines[i].split('.')
                lines[i] = f"{count}.{b}"
                count+=1
        with open('Database.txt', 'w', encoding='utf-8') as db1:
            db1.writelines(lines)
        edit_notes_qty('-')

def income_loss_edit(sign:str, amount:float) -> list:
    '''с помощью этой функции обновляю строчки, содержащие информацию о текущих балансе, доходах и расходах.
    функция возвращает обновленный список строк'''
    with open('Database.txt', 'r+', encoding='utf-8') as db:
        lines = db.readlines()
        c,d = lines[0].split()
        if sign=='+':
            a,b = lines[1].split()
            lines[0] = f"Баланс: {float(d)-amount}\n"
            lines[1] = f'Доходы: {float(b)-amount}\n'
        elif sign=='-':
            a,b = lines[2].split()
            lines[0] = f"Баланс: {float(d)+amount}\n"
            lines[2] = f'Расходы: {float(b)-amount}\n'
        return lines

def change_line_in_file(line_number:int, new_text:str):
    '''с помощью этой функции изменяю указанную строчку в БД.
    Функция принимает номер строчки, а также новый текст.
    Функция ничего не возвращает'''
    with open('Database.txt', 'r', encoding='utf-8') as db:
        lines = db.readlines()
        a,b = lines[line_number].split(': ')
        lines[line_number] = f"{a}: {new_text}\n"
        with open('Database.txt', 'w', encoding='utf-8') as db1:
            db1.writelines(lines)

def edit_line_in_file(file_path: str, line_number:int, new_text:str):
    '''с помощью этой функции меняю категорию записи (доход или расход).
    При смене записи функция соответственно изменению меняет значения доходов или расходов,
    а также общий баланс. Функция ничего не возвращает'''
    with open(file_path, 'r+', encoding='utf-8') as file:
        lines = file.readlines()
        a,b = lines[line_number].split()
        lines[line_number] = f"{a} {float(b)+float(new_text)}\n"
        if line_number==1:
            x,y = lines[0].split()
            lines[0] = f"{x} {float(y)+float(new_text)}\n"
        elif line_number==2:
            x,y = lines[0].split()
            lines[0] = f"{x} {float(y)-float(new_text)}\n"
        file.seek(0)
        file.writelines(lines)

def edit_notes_qty(sign:str):
    '''с помощью этой функции редактирую строчку, содержащую общее количество записей в БД.
    Функция ничего не возвращает'''
    with open('Database.txt', 'r+', encoding='utf-8') as db:
        lines = db.readlines()
        qty = lines[3].split()[2]
        if sign=='+':
            lines[3] = f"Количество записей: {int(qty)+1}\n"
        elif sign=='-' and int(qty)>=1:
            lines[3] = f"Количество записей: {int(qty)-1}\n"
        db.seek(0)
        db.writelines(lines)

def get_title() -> tuple:
    '''с помощью этой функции при перезапуске программы загружаю
    из БД значения доходов, расходов и общего баланса.
    Функция возвращает кортеж, содержащий значения доходов, расходов и общего баланса'''
    with open('Database.txt', 'r', encoding='utf-8') as db:
        file = db.readlines()
        a,b = file[1].split()
        c,d = file[2].split()
        e,f,g = file[3].split()
        income,loss, qty = float(b), float(d), int(g)
        return income, loss, qty

@dataclass #использую декоратор dataclass
class Note:
        note_id: int #атрибут, содержащий ID записи. Натуральное число
        note_date: date #атрибут, содержащий дату записи. тип данных date
        category: str #атрибут, содержащий наименование категории (доход/расход). Строка
        amount: float #атрибут, содержащий сумму операции. Число с плавающей точкой
        description: str #атрибут, содержащий описание операции. Строка
        def __str__(self): #метод для вывода экземпляра класса в читаемом виде
                return f"ID Записи: {self.note_id}\nДата записи: {self.note_date}\nНаименование категории: {self.category}\nСумма: {'+' if self.category=='доход' else '-'}{self.amount}\nОписание: {self.description}"
class Wallet:
    '''класс, создающий БД и управляющий ей с помощью внутренних методов'''
    def __init__(self): #метод создает экземпляр класса
        try:
            with open('Database.txt', 'r', encoding='utf-8') as db:
                self.income, self.loss, self.notes_count = get_title()
        except (FileNotFoundError, IndexError):
            with open('Database.txt', 'w', encoding='utf-8') as db:
                self.income,self.loss, self.notes_count = 0,0,0
                db.write(f"Баланс: 0\n")
                db.write(f"Доходы: 0\n")
                db.write(f"Расходы: 0\n")
                db.write(f"Количество записей: 0\n")
                db.write('СПИСОК ЗАПИСЕЙ:\n')
                db.write("*"*50+'\n')
    def menu(self):
        '''классовый метод выводит пользователю главное меню. Оно содержит:
        - текущее состояние счета (баланс, доходы и расходы)
        - команды для управления программой'''
        print('*'*70)
        self.balance()
        print('Список доступных операций:')
        print('1. Запрос баланса. Для запроса баланса введите команду "balance".')
        print('2. Добавление записи о приходе/расходе средств. Для добавления записи введите команду "add"')
        print('3. Поиск по записям. Для поиска записи введите команду "search"')
        print('4. Редактирование записи. Для редактирования записи введите команду "edit"')
        print('5. Удаление всех записей. Для удаления всех записей введите команду "clear"')
        print('6. Главное меню. Для выхода в главное меню введите команду "menu"')
        print('7. Выход. Для выхода из программы введите команду "exit"')
        return print('*'*70)
    def balance(self):
        '''классовый метод по запросу пользователя печатает текущее состояние счета (баланс/доходы/расходы)'''
        return print(f"Текущий баланс: {self.income-self.loss}\nДоходы: {self.income}\nРасходы: {self.loss}\n")
    def add(self):
        ''' классовый метод вносит в БД новую запись'''
        note_id = randint(1111111111111111, 9999999999999999) #создается случайное число в заданном диапазоне, которое будет ID записи
        note_date = date.today() #создаю переменную, содержащую текущую дату
        note_amount = input("Введите сумму операции: ") #создаю переменную, содержащую сумму операции
        while not re.fullmatch(r'[1-9]{1}[0-9]*\.?[0-9]{0,2}',note_amount): #пока введенное значение не соответствует шаблону натурального числа, числа с плавающей точкой или команде выход
            note_amount = input("Сумма должна быть числом. Введите сумму операции или команду 'выход' для возврата в главное меню: ")
            if note_amount=='выход':
                return self.menu()
        note_amount = float(note_amount)
        note_category = input("Введите наименование категории (доход/расход) или команду 'выход' для выхода в главное меню: ") #создаю переменную, содержащую наименование категории
        while note_category.lower() not in ['доход','расход']: #пока введенное значение не равно категории из списка или команде выход
                note_category = input('Неверное наименование категории. Введите наименование категории (приход/расход) или команду "выход" для возврата в главное меню: ')
                if note_category.lower()=='выход':
                    return self.menu()
        if note_category.lower()=='доход': #если запись относится к категории доход, увеличиваю общее значение доходов на заданную сумму
            self.income+=note_amount
        elif note_category.lower()=='расход':#если запись относится к категории расход, увеличиваю общее значение расходов на заданную сумму
            self.loss+=note_amount
        note_description = input('Введите описание операции: ') #создаю переменную, содержащую описание операции. свободная форма без ограничений
        new_note = Note(note_id, note_date, note_category, note_amount, note_description) #создаю экземпляр класса Note, в который передаю переменные, созданные выше
        with open('Database.txt', 'a', encoding='utf-8') as db: #в конец файла БД добавляю созданную запись
            db.write(f"{self.notes_count+1}. {new_note}\n")
            db.write('*'*50+'\n')
            self.notes_count+=1
        if note_category.lower()=='доход': #с помощью ранее созданного метода edit_line_in_file() меняю в файле БД значение строчки Доход
            edit_line_in_file('Database.txt', 1, note_amount)
        elif note_category.lower()=='расход':#с помощью ранее созданного метода edit_line_in_file() меняю в файле БД значение строчки Расход
            edit_line_in_file('Database.txt', 2, note_amount)
        edit_notes_qty('+') #в файле БД увеличиваю на 1 значение, содержащееся строчки Количество записей
        self.menu() #после создания записи, внесения ее в БД и корректировки соответствующих значений возвращаю пользователя в главное меню
    def search(self):
        '''классовый метод для поиска записи в БД'''
        notes = create_dict() #создаю переменную, содержащую словарь со всеми записями БД. Для этого использую ранее созданный метод create_dict()
        search_key = input('Введите ключ поиска (id/категория/дата/сумма): ').lower() #создаю переменную, содержащую ключ поиска
        while search_key.lower() not in ['id','категория','дата','сумма','выход']: #пока введенное значение не в списке
            search_key = input('Неверный ключ поиска. Введите ключ поиска (id/категория/дата/сумма) или выход для возврата в главное меню: ')
            if search_key.lower()=='выход':
                return self.menu()
        count = 0
        match search_key: #с помощью конструкции match-case определяю действия в зависимости от введенного ключа
            case 'id': #разбираю случай ID
                note_id = input('Введите 16-значный ID записи: ') #создаю переменную, принимающую на вход ID записи
                while not re.fullmatch(r'\d{16}',note_id): #пока введенное значение не является 16-значным числом или командой выход
                    note_id = input('Неверное значение. Введите 16-значный ID записи или выход для возврата в главное меню: ')
                    if note_id=='выход':
                        return self.menu()
                text = ''
                with open('Database.txt', 'r', encoding='utf-8') as db: #сохраняю в единую строку все записи
                    text = db.read()
                while note_id not in text: #пока введенного ID нет в базе заказов предлагаю ввести его заново или выйти в главное меню
                    note_id = input('ID не найден. Введите 16-значный ID записи или выход для возврата в главное меню: ')
                    if note_id == 'выход':
                        return self.menu()
                for i in notes: #перебираю все записи. в случае совпадения вывожу запись под требуемым ID и принудительно завершаю цикл
                    if str(i['ID записи'])==note_id:
                        pprint(i)
                        count+=1
                        break
            case 'категория': #разбираю случай категория
                note_cat = input('Введите наименование категории (доход/расход) или выход для возврата в главное меню: ').lower()
                while note_cat not in ['доход','расход','выход']: #пока введенная категория не соответствует категории из списка
                    note_cat = input('Введите наименование категории (доход/расход) или выход для возврата в главное меню: ').lower()
                    if note_cat.lower()=='выход':
                        return self.menu()
                for i in notes: #перебираю все записи и вывожу на печать те, что относятся к выбранно категории
                    if i['Наименование категории']==note_cat:
                        count+=1
                        pprint(i)
            case 'дата': #разбираю случай дата
                note_date = input('Введите дату операции в формате "ГГГГ-ММ-ДД": ') #создаю переменную, содержащую в себе искомую дату
                while not re.match(r'^(202[0-4])-(0[1-9]|1[0-2])-(0[1-9]|[12]\d|3[01])$', note_date): #пока введенное значение не соответствует требуемому шаблону
                    note_date = input('Неверный формат даты. Введите дату операции в формате "ГГГГ-ММ-ДД" или выход для возврата в главное меню: ')
                    if note_date.lower()=='выход':
                        return self.menu()
                for i in notes: #перебираю все записи. в случае совпадения даты вывожу записи на печать
                    if i['Дата записи']==note_date:
                        count+=1
                        pprint(i)
            case 'сумма': #разбираю случай сумма
                note_amount_type = input('Для поиска точной суммы введите 1.\nДля поиска суммы в заданном диапазоне введите 2: ') #предлагаю пользователю 2 опции: поиск по точной сумме или в заданном диапазоне
                while note_amount_type not in ['1','2','выход']: #пока введенное значение не равно значению из списка или команде выход
                    note_amount_type = input('Неверный формат ввода. Для поиска точной суммы введите 1.\nДля поиска суммы в заданном диапазоне введите 2.\Для возврата в главное меню введите выход: ')
                    if note_amount_type.lower()=='выход':
                        return self.menu()
                match note_amount_type: #с помощью конструкции match-case определяю действия в зависимости от выбранного пользователем типа поиска
                    case '1': #разбираю случай 1, когда поиск записей осуществляется по точной сумме
                        note_amount = input('Введите сумму операции: ') #создаю переменную, в которую сохраняю искомую сумму
                        while not re.fullmatch(r'[0-9]{1}[0-9]*\.?[0-9]{0,2}',note_amount): #пока введенное значение не соответствует шаблону натурального числа, числа в плавающей точкой или команде выход
                            note_amount = input('Сумма должна быть числом. Введите сумму операции или выход для возврата в главное меню: ')
                            if note_amount=='выход':
                                return self.menu()
                        count = 0
                        for i in notes: #перебираю все записи, в случае совпадения точной суммы вывожу на печать
                            if float(i['Сумма'][1:])==float(note_amount):
                                pprint(i)
                                count+=1
                        if count==0:
                            print('По указанным критериям записей не найдено')
                        return self.menu()
                    case '2': #разбираю случай 2, когда поиск записей осуществляется по заданному диапазону
                        note_amount_1 = input('Введите сумму операции ОТ включительно: ') #создаю переменную, в которую сохраняю нижнюю границу диапазона поиска
                        while not re.fullmatch(r'[0-9]{1}[0-9]*\.?[0-9]{0,2}',note_amount_1): #пока введенное значение не соответствует шаблону натурального числа, числа в плавающей точкой или команде выход
                            note_amount_1 = input('Сумма должна быть числом. Введите сумму операции ОТ включительно или выход для возврата в главное меню: ')
                            if note_amount_1=='выход':
                                return self.menu()
                        note_amount_2 = input('Введите сумму операции ДО включительно: ') #создаю переменную, в которую сохраняю верхнюю границу диапазона поиска
                        while not re.fullmatch(r'[0-9]{1}[0-9]*\.?[0-9]{0,2}',note_amount_2): #пока введенное значение не соответствует шаблону натурального числа, числа в плавающей точкой или команде выход
                                note_amount_2 = input('Сумма должна быть числом. Введите сумму операции ДО включительно или выход для возврата в главное меню: ')
                                if note_amount_2=='выход':
                                    return self.menu()
                        count = 0
                        for i in notes: #перебираю все записи и в случае попадания суммы в операции в заданный диапазон вывожу на печать
                            if float(note_amount_1)<=float(i['Сумма'][1:])<=float(note_amount_2):
                                pprint(i)
                                count+=1
        if count==0:
            print('По указанным критериям записей не найдено')
        return self.menu()
    def edit(self):
        '''классовый метод для редактирования или удаления существующей записи'''
        notes = create_dict() #создаю переменную, содержащую все записи
        if len(notes)==0: #если список записей пуст, сообщаю, что редактировать нечего и возвращаю клиента на главное меню
            print('Нет доступных записей для редактирования')
            return self.menu()
        note = input('Введите 16-значный ID записи: ') #создаю переменную, принимающую ID записи, предназначенную для редактирования или удаления
        while not re.fullmatch(r'\d{16}', note): #пока введенное значение не соответствует 16-значному числу
            note = input('Введите 16-значный ID записи. Для поиска ID записи воспользуйтесь функцией "Поиск по записям": ')
            if note=='выход':
                return self.menu()
        note = int(note)
        with open('Database.txt', 'r', encoding='utf-8') as db: #проверяю наличие введенного ID в БД
            while f" {note}\n" not in db.read(): #пока введенного значения нет в БД предлагаю пользователю ввести ID заново или вернуться в главное меню
                note = input('ID записи не найден.\nВведите 16-значный ID записи. Для поиска ID записи воспользуйтесь функцией "Поиск по записям": ')
                if note=='выход':
                    return self.menu()
        action = input('Введите действие (удалить/изменить): ') #предлагаю пользователю выбрать действие (удалить или изменить запись)
        while action not in ['удалить','изменить']: #пока введенного значения нет в списке допустимых действий предлагаю ввести его заново или вернуться на главное меню
            action = input('Неверное действие. Введите действие (удалить/изменить) или выход для возврата в главное меню: ')
            if action=='выход':
                return self.menu()
        ID_line = 0
        with open('Database.txt', 'r', encoding='utf-8') as db: #с помощью контекстного менеджера перебираю все строки БД, чтобы сохранить в переменную ID_line номер строки, содержащую номер искомого ID
            lines = db.readlines()
            for i in range(len(lines)):
                if str(note) in lines[i]:
                    ID_line = i
                    break
        match action: #с помощью конструкции match-case определяю действия в зависимости от выбранной пользователем опции (удалить/изменить)
            case 'удалить': #разбираю случай удалить
                delete_note(ID_line) #удаляю искомую запись с помощью ранее созданной функции delete_note, в которую передаю номер строки, содержащую искомый ID
                self.income, self.loss, self.notes_count = get_title() #обновляю атрибуты класса, содержащие значения доходов, расходов и баланса
                print(f'Запись {note} успешно удалена')
            case 'изменить': #разбираю случай изменить
                delete_note(ID_line) #удаляю искомую запись с помощью ранее созданной функции delete_note, в которую передаю номер строки, содержащую искомый ID
                self.income, self.loss, self.notes_count = get_title() #обновляю атрибуты класса, содержащие значения доходов, расходов и баланса
                self.add() #с помощью классового метода add создаю новую запись и помещаю ее в конец списка
                change_line_in_file(-6, note) #меняю у последней созданной записи ID на искомый
                print(f'Запись {note} успешно изменена')
        self.menu()
    def clear(self):
        '''классовый метод, предназначенный для очищения БД от всех записей'''
        res = input('Вы уверены, что хотите удалить все записи?\nЕсли да, введите Y\nЕсли нет, введите N:\n').lower() #создаю переменную, принимающую подтверждение пользователя
        while res not in ['y','n']: #пока введенного пользователем значения нет в списке требую подтверждения или отказа от пользователя
            res = input('Вы уверены, что хотите удалить все записи?\nЕсли да, введите Y\nЕсли нет, введите N:\n').lower()
        match res: #с помощью конструкции match-case разбираю выбор пользователя
            case 'y': #разбираю случай, если пользователь готов удалить все записи
                self.income,self.loss, self.notes_count = 0,0,0 #обнуляю атрибуты экземпляра класса, содержащие значения доходов, расходов и баланса
                with open('Database.txt', 'w', encoding='utf-8') as db: #с помощью контекстного менеджера обнуляю БД и переписываю заголовок
                    db.write(f"Баланс: 0\n")
                    db.write(f"Доходы: 0\n")
                    db.write(f"Расходы: 0\n")
                    db.write(f"Количество записей: 0\n")
                    db.write('СПИСОК ЗАПИСЕЙ:\n')
                    db.write("*"*50+'\n')
                print('Все записи успешно удалены')
            case 'n': #разбираю случай, если пользователь отказывается удалить все записи
                self.menu() #возвращаю пользователя в главное меню
w = Wallet() #создаю экземпляр класса Wallet
print('Добро пожаловать в приложение Wallet') #приветствую пользователя
print('Оно предназначено для учета личных доходов и расходов')
w.menu() #вызываю главное меню
cmds = ['balance', 'add', 'search', 'clear', 'edit', 'menu'] #создаю переменную, содержащую в себе все доступные команды
t = ''
while t!='exit': #с помощью цикла while заставляю программу работать, пока пользователь сам не введет команду exit
    t = input("Введите команду: ") #создаю переменную, которая принимает выбранную пользователем команду
    if t=='exit': #если команда exit, то завершаю выполнение программы
        break
    if t in cmds: #если введенная команда в списке доступных
        eval(f"w.{t}()") #то с помощью функции eval вызываю у экземпляра класса Wallet соответствующий метод
    else:
        print('Неверная команда')
        continue
#спасибо за внимание